{"version":3,"sources":["webpack://groupArrayElements/webpack/universalModuleDefinition","webpack://groupArrayElements/./src/lib.js","webpack://groupArrayElements/webpack/bootstrap","webpack://groupArrayElements/webpack/startup"],"names":["root","factory","exports","module","define","amd","this","array","numGroups","Array","isArray","Error","Number","isInteger","actualNumGroups","Math","min","length","groupSize","ceil","groups","i","startIndex","endIndex","group","slice","push","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAA4B,mBAAID,IAEhCD,EAAyB,mBAAIC,IAR/B,CASGK,MAAM,WACT,O,iDCsCA,UArCA,SAA4BC,EAAOC,GAGlC,GAAa,MAATD,IAAkBE,MAAMC,QAAQH,GACnC,MAAM,IAAII,MAAM,6BAGjB,GAAiB,MAAbH,IAAsBI,OAAOC,UAAUL,IAAcA,EAAY,EACpE,MAAM,IAAIG,MAAM,2CAajB,IARA,IAAMG,EAAkBC,KAAKC,IAAIR,EAAWD,EAAMU,QAI5CC,EAAYH,KAAKI,KAAKZ,EAAMU,OAASH,GAGrCM,EAAS,GACNC,EAAI,EAAGA,EAAIP,IAAmBO,EAAG,CAKzC,IAAMC,EAAaD,EAAIH,EACjBK,EAAWD,EAAaJ,EAGxBM,EAAQjB,EAAMkB,MAAMH,EAAYC,GACtCH,EAAOM,KAAKF,GAGb,OAAOJ,KC5CJO,EAA2B,GCE/B,ODCA,SAASC,EAAoBC,GAE5B,GAAGF,EAAyBE,GAC3B,OAAOF,EAAyBE,GAAU3B,QAG3C,IAAIC,EAASwB,EAAyBE,GAAY,CAGjD3B,QAAS,IAOV,OAHA4B,EAAoBD,GAAU1B,EAAQA,EAAOD,QAAS0B,GAG/CzB,EAAOD,QCjBR0B,CAAoB,K","file":"group-array-elements.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"groupArrayElements\"] = factory();\n\telse\n\t\troot[\"groupArrayElements\"] = factory();\n})(this, function() {\nreturn ","/**\n * Group the contents of an array into N groups of equal size.\n * If the array does not divide equally by N the last group will contain the remainder.\n * The actual number of groups may be fewer than N if there are not enough elements in the source\n * array (The assumption here is we don't want empty groups).\n *\n * @template T\n * @param {Array<T>} array The source array containing the elements to be grouped\n * @param {number} numGroups The target number of groups to extract from the array. Must be a positive integer\n * @returns {Array<Array<T>>} Array of grouped elements\n */\nfunction groupArrayElements(array, numGroups) {\n\t// Validate arguments.\n\t// \"== null\" will check for both \"null\" and \"undefined\".\n\tif (array == null || !Array.isArray(array)) {\n\t\tthrow new Error(\"'array' must be an array.\");\n\t}\n\n\tif (numGroups == null || !Number.isInteger(numGroups) || numGroups < 1) {\n\t\tthrow new Error(\"'numGroups' must be a positive integer.\");\n\t}\n\n\t// Ensure the number of groups is less than or equal to the array length so that we don't end\n\t// up with more groups than we have elements for.\n\tconst actualNumGroups = Math.min(numGroups, array.length);\n\n\t// The array length might not exactly divide by the number of groups so we must use ceil to\n\t// ensure we get the next whole number and avoid missing elements from the end of the array.\n\tconst groupSize = Math.ceil(array.length / actualNumGroups);\n\n\t// Extract the groups from the array.\n\tconst groups = [];\n\tfor (let i = 0; i < actualNumGroups; ++i) {\n\t\t// Array slice copies a section of the array from from startIndex up to (but not including)\n\t\t// endIndex, this means the endIndex is always `groupSize` larger than startIndex.\n\t\t// Interestingly we also don't need to worry about overshooting the endIndex on the last\n\t\t// group as the Array slice method handles that for us.\n\t\tconst startIndex = i * groupSize;\n\t\tconst endIndex = startIndex + groupSize;\n\n\t\t// Extract the group and add it to the array of groups.\n\t\tconst group = array.slice(startIndex, endIndex);\n\t\tgroups.push(group);\n\t}\n\n\treturn groups;\n}\n\nexport default groupArrayElements;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(777);\n"],"sourceRoot":""}